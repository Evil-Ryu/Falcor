#pragma once


#include "GLSLDefines.slangh"


// Notation

// E = Random sample for BRDF.
// N = Normal of the macro surface.
// H = Normal of the micro surface.
// V = View vector going from surface's position towards the view's origin.
// L = Light ray direction

// D = Microfacet NDF
// G = Shadowing and masking
// F = Fresnel

// Vis = G / (4*NoL*NoV)
// f = Microfacet specular BRDF = D*G*F / (4*NoL*NoV) = D*Vis*F


#define MAT_TYPE_OPAQUE 0.
#define MAT_TYPE_TRANSLUCENT 1.
#define MAT_TYPE_SUBSURFACE 2.
#define MAT_TYPE_VOLUME 3.
#define MAT_TYPE_VOLUME_BOUND 4.


struct VolumeContext
{
    vec3 absorptionCoeff;
    vec3 scatteringCoeff;
    vec3 extinctionCoeff; // = absorption + scattering
    vec3 scatteringAlbedo; // scatteringAlbedo = scattering / extinction
    bool heteregeneous;
    bool multiScatter;
    // g in Henyey Greenstein phase function, (-1, 1)
    // backwards scattering (g < 0),
    // isotropic scattering (g = 0),
    // forward scattering (g > 0)
    float g;
    float volumeMatId;
};

struct RyuMaterial
{
    float type;
    vec3 albedo;
    vec3 specularCol;
    float shininess;
    float roughness;
    float F0;
    float anisotropy;

    float transparency;
    float eta;


    vec3 absorptionCoeff;
    vec3 scatteringCoeff;
    vec3 extinctionCoeff; // = absorption + scattering
    vec3 scatteringAlbedo; // scatteringAlbedo = scattering / extinction
    bool heteregeneous;
    bool multiScatter;
    // g in Henyey Greenstein phase function, (-1, 1)
    // backwards scattering (g < 0),
    // isotropic scattering (g = 0),
    // forward scattering (g > 0)
    float g;
    float volumeMatId;

    bool hasVolume()
    {
        return volumeMatId > 0.;
    }
};


// simple diffuse 
void MakeDefaultMaterial(out RyuMaterial mat)
{
    mat.type = MAT_TYPE_OPAQUE;
    mat.albedo = vec3(1., 0., 1.);
    mat.specularCol = vec3(1);
    mat.shininess = 16.;
    mat.roughness = 1.;
    mat.F0 = 0.04;
    mat.anisotropy = 0.;
    mat.transparency = 0.;
    mat.eta = 1.;

    mat.extinctionCoeff = vec3(0.);
    mat.scatteringAlbedo = vec3(1.);
}


bool hasVolume(RyuMaterial mat)
{
    return mat.volumeMatId > 0.;
}

// for dielectric
float schlickFresnel(float F0, float lightDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - lightDotHalf, 5.);
}

// for metal
vec3 schlickFresnel(vec3 F0, float lightDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - lightDotHalf, 5.);
}

// standard phong brdf
// kd*(1./pi) + ks*((n+2)/2pi * (reflect * eye)^n
vec3 phongBrdf(vec3 toLight, vec3 toEye, vec3 normal, vec3 pos, RyuMaterial mat)
{
    vec3 wr = reflect(-toLight, normal);
    vec3 wh = normalize(toLight + toEye);

    float F = schlickFresnel(mat.F0, max(0., dot(toLight, wh)));

    float diff = (1. - F) * 1. / PI;
    float spec = F * ((mat.shininess + 2.) / (2. * PI)) *
        pow(max(0., dot(wr, toEye)), mat.shininess);


    vec3 diff_refl = diff * mat.albedo;
    vec3 spec_refl = spec * mat.specularCol;

    return mix(spec_refl, diff_refl, mat.roughness);
}


vec3 evaluateIsotropicPhaseBsdf()
{
    float pdf = 0.25 / PI;
    return vec3(pdf, pdf, pdf);
}


vec4 sampleIsotropicPhaseBsdf(vec2 rnd, out vec3 L)
{
    vec4 res = UniformSampleSphere(rnd);
    L = res.xyz;
    float pdf = res.w;
    vec3 brdf = evaluateIsotropicPhaseBsdf();
    return vec4(brdf, pdf);
}



float HenyeyGreensteinPdf(float costheta, float g)
{
    float g1 = 1. + g * g;
    float g2 = 1. - g * g;
    return 0.25 * g2 / (PI * pow(g1 - 2.0f * g * costheta, 1.5));
}

float HenyeyGreensteinInvertCdf(float xi, float g)
{
    float g1 = 1. + g * g;
    float g2 = 1. - g * g;
    float g3 = .5 / g;

    float t = g2 / (1. - g + 2. * g * xi);
    return g3 * (g1 - t * t);
}

// L is the sampled outgoing direction
// return: the brdf value
vec3 EvaluateHenyeyGreenstein(vec3 L, vec3 V, float g)
{
    bool isotropic = g == 0.;

    float pdf = 1.;

    if (isotropic)
    {
        pdf = 0.25 / PI;
    }
    else
    {
        float cosTheta = dot(-V, L);
        pdf = HenyeyGreensteinPdf(cosTheta, g);
    }

    return vec3(pdf);
}

vec4 sampleHenyeyGreenstein(vec2 rnd, in vec3 V, out vec3 L, float g)
{
    bool isotropic = g == 0.;

    float pdf = 1.;

    if (isotropic)
    {
        sampleIsotropicPhaseBsdf(rnd, L);
        pdf = 0.25 / PI;
    }
    else
    {
        float phi = rnd.x * 2. * PI;
        float cosTheta = HenyeyGreensteinInvertCdf(rnd.y, g);
        float sinTheta = sqrt(1. - cosTheta * cosTheta);
        float3x3 tangentBasis = GetTangentBasis(-V);

        L = sinTheta * sin(phi) * tangentBasis[0] + sinTheta * cos(phi) * tangentBasis[1] +
            cosTheta * (-V);
        pdf = HenyeyGreensteinPdf(cosTheta, g);
    }

    vec3 brdf = EvaluateHenyeyGreenstein(L, V, g);

    return vec4(brdf, pdf);
}


// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX(float a2, float NoH)
{
    float d = (NoH * a2 - NoH) * NoH + 1;	// 2 mad
    return a2 / (PI * d * d);					// 4 mul, 1 rcp
}

// Convert a roughness and an anisotropy factor into GGX alpha values respectively for the major and minor axis of the tangent frame
// alpha = roughness * roughness
void GetAnisotropicRoughness(float Alpha, float Anisotropy, out float ax, out float ay)
{
    // Anisotropic parameters: ax and ay are the roughness along the tangent and bitangent	
    // Kulla 2017, "Revisiting Physically Based Shading at Imageworks"
    ax = max(Alpha * (1.0 + Anisotropy), 0.001f);
    ay = max(Alpha * (1.0 - Anisotropy), 0.001f);
}

// Anisotropic GGX
// [Burley 2012, "Physically-Based Shading at Disney"]
float D_GGXaniso(float ax, float ay, float NoH, float XoH, float YoH)
{
    float a2 = ax * ay;
    vec3 V = vec3(ay * XoH, ax * YoH, a2 * NoH);
    float S = dot(V, V);

    return (1.0f / PI) * a2 * pow(a2 / S, 2.);
}

// Smith term for GGX
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
float Vis_Smith(float a2, float NoV, float NoL)
{
    float Vis_SmithV = NoV + sqrt(NoV * (NoV - NoV * a2) + a2);
    float Vis_SmithL = NoL + sqrt(NoL * (NoL - NoL * a2) + a2);
    return 1. / (Vis_SmithV * Vis_SmithL);
}

// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float Vis_SmithJoint(float a2, float NoV, float NoL)
{
    float Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
    float Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
    return 0.5 * 1. / (Vis_SmithV + Vis_SmithL);
}

vec3 F_Schlick(vec3 F0, vec3 F90, float VoH)
{
    float Fc = pow(1 - VoH, 5.);
    return F90 * Fc + (1 - Fc) * F0;
}



// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
vec2 GGXEvalReflection(vec3 L, vec3 V, vec3 H, vec2 Alpha)
{
    const float NoL = saturate(L.z);
    const float NoV = saturate(V.z);

    if (NoL > 0 && NoV > 0)
    {
        const float D = D_GGXaniso(Alpha.x, Alpha.y, H.z, H.x, H.y);
        // See implementation in Vis_SmithJointAniso for G2/(4*NoV*NoL)
        // We can simplify a bit further since we need both the weight G2/G1 and the pdf
        const float LenL = length(vec3(L.x * Alpha.x, L.y * Alpha.y, NoL));
        const float LenV = length(vec3(V.x * Alpha.x, V.y * Alpha.y, NoV));
        const float Weight = NoL * (LenV + NoV) / (NoV * LenL + NoL * LenV);
        const float Pdf = 0.5 * D * rcp(LenV + NoV);

        return vec2(Weight, Pdf);
    }
    return vec2(0);
}

// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
vec2 GGXEvalRefraction(vec3 L, vec3 V, vec3 H, vec2 Alpha, float Eta)
{
    const float NoV = clamp(V.z, 0., 1.);
    const float NoL = clamp(-L.z, 0., 1.); // NOTE: L should point down

    // This checks that V and L point in opposite sides and that the half-vector is valid
    if (NoL > 0 && NoV > 0 && H.z > 0)
    {
        const float D = D_GGXaniso(Alpha.x, Alpha.y, H.z, H.x, H.y);

        const float VoH = clamp(dot(V, H), 0., 1.);
        const float LoH = clamp(-dot(L, H), 0., 1.);

        // Same as logic above, only the pdf math differs slightly
        const float LenL = length(vec3(L.x * Alpha.x, L.y * Alpha.y, NoL));
        const float LenV = length(vec3(V.x * Alpha.x, V.y * Alpha.y, NoV));
        const float Weight = NoL * (LenV + NoV) / (NoV * LenL + NoL * LenV);
        const float Pdf = (LoH * VoH * Eta * Eta * 2.0 * D) / (pow(VoH - Eta * LoH, 2.) * (LenV + NoV));

        return vec2(Weight, Pdf);
    }
    return vec2(0);
}
