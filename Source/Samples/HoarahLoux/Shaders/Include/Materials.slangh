#pragma once


#include "GLSLDefines.slangh"


// Notation

// E = Random sample for BRDF.
// N = Normal of the macro surface.
// H = Normal of the micro surface.
// V = View vector going from surface's position towards the view's origin.
// L = Light ray direction

// D = Microfacet NDF
// G = Shadowing and masking
// F = Fresnel

// Vis = G / (4*NoL*NoV)
// f = Microfacet specular BRDF = D*G*F / (4*NoL*NoV) = D*Vis*F




struct RyuMaterial
{
    vec3 albedo;
    vec3 specularCol;
    float shininess;
    float roughness;
    float F0;
    float anisotropy;
    float transparency;
    float eta;
    float volumeId;  // indirection to different volume parameters,  -1 means no volume
};

struct VolumeMaterial
{
    vec3 extinction; // absorption + scattering

    // scatteringAlbedo * extinction = scattering coefficient
    vec3 scatteringAlbedo;
};

// simple diffuse 
void MakeDefaultMaterial(out RyuMaterial mat)
{
    mat.albedo = vec3(1., 0., 1.);
    mat.specularCol = vec3(1);
    mat.shininess = 16.;
    mat.roughness = 1.;
    mat.F0 = 0.04;
    mat.anisotropy = 0.;
    mat.transparency = 0.;
    mat.eta = 1.;
    mat.volumeId = -1.;
}

// for dielectric
float schlickFresnel(float F0, float lightDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - lightDotHalf, 5.);
}

// for metal
vec3 schlickFresnel(vec3 F0, float lightDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - lightDotHalf, 5.);
}

// standard phong brdf
// kd*(1./pi) + ks*((n+2)/2pi * (reflect * eye)^n
vec3 phongBrdf(vec3 toLight, vec3 toEye, vec3 normal, vec3 pos, RyuMaterial mat)
{
    vec3 wr = reflect(-toLight, normal);
    vec3 wh = normalize(toLight + toEye);

    float F = schlickFresnel(mat.F0, max(0., dot(toLight, wh)));

    float diff = (1. - F) * 1. / PI;
    float spec = F * ((mat.shininess + 2.) / (2. * PI)) *
        pow(max(0., dot(wr, toEye)), mat.shininess);


    vec3 diff_refl = diff * mat.albedo;
    vec3 spec_refl = spec * mat.specularCol;

    return mix(spec_refl, diff_refl, mat.roughness);
}



// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX(float a2, float NoH)
{
    float d = (NoH * a2 - NoH) * NoH + 1;	// 2 mad
    return a2 / (PI * d * d);					// 4 mul, 1 rcp
}

// Convert a roughness and an anisotropy factor into GGX alpha values respectively for the major and minor axis of the tangent frame
// alpha = roughness * roughness
void GetAnisotropicRoughness(float Alpha, float Anisotropy, out float ax, out float ay)
{
    // Anisotropic parameters: ax and ay are the roughness along the tangent and bitangent	
    // Kulla 2017, "Revisiting Physically Based Shading at Imageworks"
    ax = max(Alpha * (1.0 + Anisotropy), 0.001f);
    ay = max(Alpha * (1.0 - Anisotropy), 0.001f);
}

// Anisotropic GGX
// [Burley 2012, "Physically-Based Shading at Disney"]
float D_GGXaniso(float ax, float ay, float NoH, float XoH, float YoH)
{
    float a2 = ax * ay;
    vec3 V = vec3(ay * XoH, ax * YoH, a2 * NoH);
    float S = dot(V, V);

    return (1.0f / PI) * a2 * pow(a2 / S, 2.);
}

// Smith term for GGX
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
float Vis_Smith(float a2, float NoV, float NoL)
{
    float Vis_SmithV = NoV + sqrt(NoV * (NoV - NoV * a2) + a2);
    float Vis_SmithL = NoL + sqrt(NoL * (NoL - NoL * a2) + a2);
    return 1. / (Vis_SmithV * Vis_SmithL);
}

// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float Vis_SmithJoint(float a2, float NoV, float NoL)
{
    float Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
    float Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
    return 0.5 * 1. / (Vis_SmithV + Vis_SmithL);
}

vec3 F_Schlick(vec3 F0, vec3 F90, float VoH)
{
    float Fc = pow(1 - VoH, 5.);
    return F90 * Fc + (1 - Fc) * F0;
}



// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
vec2 GGXEvalReflection(vec3 L, vec3 V, vec3 H, vec2 Alpha)
{
    const float NoL = saturate(L.z);
    const float NoV = saturate(V.z);

    if (NoL > 0 && NoV > 0)
    {
        const float D = D_GGXaniso(Alpha.x, Alpha.y, H.z, H.x, H.y);
        // See implementation in Vis_SmithJointAniso for G2/(4*NoV*NoL)
        // We can simplify a bit further since we need both the weight G2/G1 and the pdf
        const float LenL = length(vec3(L.x * Alpha.x, L.y * Alpha.y, NoL));
        const float LenV = length(vec3(V.x * Alpha.x, V.y * Alpha.y, NoV));
        const float Weight = NoL * (LenV + NoV) / (NoV * LenL + NoL * LenV);
        const float Pdf = 0.5 * D * rcp(LenV + NoV);

        return vec2(Weight, Pdf);
    }
    return vec2(0);
}

// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
vec2 GGXEvalRefraction(vec3 L, vec3 V, vec3 H, vec2 Alpha, float Eta)
{
    const float NoV = clamp(V.z, 0., 1.);
    const float NoL = clamp(-L.z, 0., 1.); // NOTE: L should point down

    // This checks that V and L point in opposite sides and that the half-vector is valid
    if (NoL > 0 && NoV > 0 && H.z > 0)
    {
        const float D = D_GGXaniso(Alpha.x, Alpha.y, H.z, H.x, H.y);

        const float VoH = clamp(dot(V, H), 0., 1.);
        const float LoH = clamp(-dot(L, H), 0., 1.);

        // Same as logic above, only the pdf math differs slightly
        const float LenL = length(vec3(L.x * Alpha.x, L.y * Alpha.y, NoL));
        const float LenV = length(vec3(V.x * Alpha.x, V.y * Alpha.y, NoV));
        const float Weight = NoL * (LenV + NoV) / (NoV * LenL + NoL * LenV);
        const float Pdf = (LoH * VoH * Eta * Eta * 2.0 * D) / (pow(VoH - Eta * LoH, 2.) * (LenV + NoV));

        return vec2(Weight, Pdf);
    }
    return vec2(0);
}
