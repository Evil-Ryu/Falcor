#define vec4 float4
#define vec3 float3
#define vec2 float2
#define mix lerp
#define fract frac


cbuffer ToyCB
{
    float2 iResolution;
    float iGlobalTime;
    float iFrame;
    float iCameraDirty;
    float iMaxSPP;

    float3 RayOrigin;
    float3 RayTarget;
};

layout(binding = 0) SamplerState iChannel0Sampler : register(s0);
layout(binding = 1) texture2D iPass0Output : register(t0);

#define MAX_BOUNCES 5
#define INTER_THRESHOLD .001
#define PI 3.1415926535

static float seed;

float hash11(float p)
{
    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));
    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
    return fract(p2.x * p2.y * 95.4337);
}

float hash12(vec2 p)
{
	p  = fract(p * vec2(5.3983, 5.4427));
    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));
	return fract(p.x * p.y * 95.4337);
}

vec3 hash31(float p)
{
    vec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));
    p2 += dot(p2.yzx, p2.xyz + vec3(21.5351, 14.3137, 15.3219));
    return fract(vec3(p2.x * p2.z * 95.4337, p2.x * p2.y * 97.597, p2.y * p2.z * 93.8365));
}

vec2 hash21(float p)
{
    vec2 p2 = fract(p * vec2(5.3983, 5.4427));
    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
    return fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));
}

vec3 ortho(vec3 v)
{
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);
}


// pdf = costheta / pi
vec3 getHemisphereSampleCosWeighted(vec3 dir, float power)
{
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));
    vec2 r = hash21(seed++);
    r.x = r.x * 2. * PI;
    r.y = pow(r.y, 1.0 / (power + 1.0));
    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}

// sample propotional to a cone centered at the normal
// extent = 1 - costheta
// theta is the radian angel of the cone
// pdf = 1 / (2pi * (1-costheta))
vec3 getConeSample(vec3 dir, float extent)
{
    // Create orthogonal vector (fails for z,y = 0)
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));

    vec2 r = hash21(seed++);

    r.x = r.x * 2. * PI;
    r.y = 1.0 - r.y * extent;

    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}


// formula 36, sample proportional to cosine lobe around dir
// power is the power of cos
// pdf = (n + 1) / 2pi * cos^n
vec3 getConeSampleCosWeighted(vec3 dir, float power)
{
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));

    vec2 r = hash21(seed++);

    r.x = 2. * PI * r.x;
    r.y = 1.0 - pow(r.y, 1. / (power + 1.));

    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}

vec3 getPhoneSpecularSample(vec3 dir, float power)
{
    return getConeSampleCosWeighted(dir, power);
}

// for dielectric
float schlickFresnel(float F0, float viewDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - viewDotHalf, 5.);
}

// for metal
vec3 schlickFresnel(vec3 F0, float viewDotHalf)
{
    return F0 + (1. - F0) * pow(1.0 - viewDotHalf, 5.);
}

// standard phong brdf
// kd*(1./pi) + ks*((n+2)/2pi * (reflect * eye)^n
struct PhongMaterial
{
    vec3 albedo;
    vec3 specularCol;
    float shininess;
    float roughness;
    float F0;
};

vec3 phongBrdf(vec3 wi, vec3 wo, vec3 normal, vec3 pos, PhongMaterial mat)
{
    vec3 wr = reflect(-wi, normal);
    vec3 wh = normalize(wi + wo);

    float F = schlickFresnel(mat.F0, max(0., dot(wi, wh)));

    float diff = (1. - F) * 1. / PI;
    float spec = F * ((mat.shininess + 2.) / (2. * PI)) *
        pow(max(0., dot(wr, wo)), mat.shininess);


    vec3 diff_refl = diff * mat.albedo;
    vec3 spec_refl = spec * mat.specularCol;

    return mix(spec_refl, diff_refl, mat.roughness);
}

PhongMaterial getPhongMaterial(float id)
{
    PhongMaterial mat;
    mat.albedo = vec3(1., 0., 1.);
    mat.specularCol = vec3(1., 0., 1.);
    mat.shininess = 16.;
    mat.roughness = .5;
    mat.F0 = 0.03;

    if (id == 0.)
    {
        mat.albedo = vec3(1., .2, .1);
        mat.specularCol = vec3(1);
        mat.roughness = .9;
    }
    else if (id == 1.)
    {
        mat.albedo = vec3(.2, 1., .1);
        mat.specularCol = vec3(1);
        mat.roughness = 0.3;
    }
    else if (id == 2.)
    {
        mat.albedo = vec3(.8);
        mat.specularCol = vec3(1);
    }
    return mat;
}

vec3 rndunit(float s) {
    return normalize(tan(hash31(s)));
}

float sdBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

vec2 map(vec3 p)
{
    float d1 = length(p) - 1.;
    float d2 = sdBox(p - vec3(2.2, .0, .0), vec3(.5,1.,.3));
    float d3 = abs(p.y + .9);
    float d = d1;
    float id = 0.;

    if (d2 < d) { d = d2; id = 1.; }
    if (d3 < d) { d = d3; id = 2.; }

    return vec2(d, id);
}

vec3 getNormal(vec3 p)
{
    float t = 1.;
    vec3 n = vec3(0);
    for (int i = 0; i < 4; i++)
    {
        vec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);
        n += e * map(p + .001 * e * t).x;
    }
    return normalize(n);
}

vec2 intersect(vec3 ro, vec3 rd, float dist)
{
    float t = 0.0;
    vec2 res = vec2(10);

    for (int i = 0; i < 128; ++i)
    {
        if (res.x < INTER_THRESHOLD || t > dist)
        {
            break;
        }

        res = map(ro + t * rd);
        t += res.x;
    }

    return vec2(t, res.y);
}

// https://github.com/Syntopia/Fragmentarium/blob/master/Fragmentarium-Source/Examples/Include/Sunsky.frag
//static float sunSize = 0.53; //degree
static float sunSize = 10.;
static float sunAngularDiameterCos = cos(sunSize * PI / 180.0);

vec3 getDirectLighting(vec3 v, vec3 ro, vec3 normal, float matid)
{
    vec3 lightDir = normalize(vec3(1., 1., -1.));
    vec3 col = vec3(0);
    float costheta = dot(lightDir, normal);
    if (costheta <= 0.)
        return col;

    vec3 rd = lightDir;// getConeSample(lightDir, 1. - sunAngularDiameterCos);
    vec3 sunCol = vec3(1.1, .5, .2);

    vec2 res = intersect(ro + (INTER_THRESHOLD*2.) * normal, rd, 20.);

    if (res.x >= 20.)
    {
        PhongMaterial mat = getPhongMaterial(matid);
        col = costheta * sunCol * phongBrdf(-rd, v, normal, ro, mat);
    }

    return col;
}

vec3 getAlbedo(float id)
{
    if (id == 0.) { return vec3(1., 0.1, 0.1); }
    else if (id == 1.) { return vec3(0.1, 1., 0.1); }
    else if (id == 2.) { return vec3(.5); }
    return vec3(0);
}


vec3 scene(vec3 ro, vec3 rd)
{
    vec3 col = vec3(1.);
    vec3 direct = vec3(0);

    // only in hemisphere
    vec3 sky = vec3(0.1, .5, 1.);// *max(0., -rd.y);
    vec2 res;
    vec3 pos, n;

    // bounces
    for (int i = 0; i < MAX_BOUNCES; ++i)
    {
        res = intersect(ro, rd, 100.);

        if (res.x >= 100.)
        {
            // indirect part
            // it has to finally hit a light or the sky to have color
            // or there will be only direct part
            direct = direct + col * sky;
            break;
        }

        pos = ro + res.x * rd;
        n = getNormal(pos);

        //vec3 albedo = getAlbedo(res.y);
        PhongMaterial mat = getPhongMaterial(res.y);

        float rnd = hash11(seed++);

        // russian roullete, importance sampling
       /* if (rnd > mat.roughness)
        {

        }
        else
        {

        }*/

        vec3 ord = rd;

        rd = normalize(getHemisphereSampleCosWeighted(n, 1.));
        //float costheta = max(0.0001, dot(n, outgoingDir));  // avoid divided by zero
        //float pdf = costheta / PI;
        //col *= albedo / PI * costheta / pdf   --> albedo * costheta;
        //col *= mat.albedo;
        vec3 fr = phongBrdf(-rd, -ord, n, pos, mat);
        col *= fr * PI;

        ro = pos + (INTER_THRESHOLD * 2.) * n;

        // direct part, NEE, use MIS to optimize
        direct += col * getDirectLighting(ord, pos, n, res.y);
    }

    return direct;
}


// basic truchet
vec4 mainImage(vec2 fragCoord)
{
    seed = iGlobalTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;

    vec2 offset = -0.5 + hash21(seed++);
    vec2 p = (fragCoord + offset) / iResolution.xy; // (-iResolution.xy + 2.0 * (fragCoord + offset)) / iResolution.y;


    // origin is at the topleft corner for hlsl
    p.y = 1. - p.y;
    p = 2. * p - 1.;
    p.x *= iResolution.x / iResolution.y;

    // note falcor's camera is right handed, so we need reverse x
    vec3 ro = vec3(RayOrigin.x, RayOrigin.y, RayOrigin.z);
    vec3 ta = RayTarget;

    vec3 forward = normalize(ta - ro);
    vec3 right = normalize(cross(vec3(0, 1, 0), forward));
    vec3 up = normalize(cross(forward, right));

    vec3 rd = normalize(p.x * right + p.y * up + 1.8 * forward);


    vec3 finalCol = scene(ro, rd);
    float k = 1.;

    if (iFrame > 0. && iCameraDirty == 0.)
    {
        vec4 prevCol = iPass0Output.Load(vec3(fragCoord, 0));
        k = prevCol.w;

        finalCol.xyz = prevCol.xyz * (k / (k + 1.)) + finalCol.xyz * (1. / (k + 1.));

        if (k >= iMaxSPP)
        {
            finalCol = prevCol.xyz;
        }
    }

   
    return vec4(finalCol.xyz, k + 1.);
}

float4 main(float2 texC : TEXCOORD) : SV_TARGET
{
    return mainImage(texC * iResolution);
}
