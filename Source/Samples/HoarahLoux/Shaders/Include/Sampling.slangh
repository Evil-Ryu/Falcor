#pragma once

#include "GLSLDefines.slangh"
#include "Randoms.slangh"


#define PI 3.1415926535

vec3 ortho(vec3 v)
{
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);
}


// pdf = costheta / pi
vec3 getHemisphereSampleCosWeighted(vec3 dir, float power, inout float seed)
{
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));
    vec2 r = hash21(seed++);
    r.x = r.x * 2. * PI;
    r.y = pow(r.y, 1.0 / (power + 1.0));
    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}

vec3 getHemisphereSampleCosWeighted(vec3 n, inout float seed)
{
    vec3 rnd = hash31(seed++);
    return normalize(n + rnd);
}

// sample propotional to a cone centered at the normal
// extent = 1 - costheta
// theta is the radian angel of the cone
// pdf = 1 / (2pi * (1-costheta))
vec3 getConeSample(vec3 dir, float extent, inout float seed)
{
    // Create orthogonal vector (fails for z,y = 0)
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));

    vec2 r = hash21(seed++);

    r.x = r.x * 2. * PI;
    r.y = 1.0 - r.y * extent;

    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}


// formula 36, sample proportional to cosine lobe around dir
// power is the power of cos
// pdf = (n + 1) / 2pi * cos^n
vec3 getConeSampleCosWeighted(vec3 dir, float power, inout float seed)
{
    dir = normalize(dir);
    vec3 o1 = normalize(ortho(dir));
    vec3 o2 = normalize(cross(dir, o1));

    vec2 r = hash21(seed++);

    r.x = 2. * PI * r.x;
    r.y = 1.0 - pow(r.y, 1. / (power + 1.));

    float oneminus = sqrt(1.0 - r.y * r.y);
    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;
}

vec3 getPhoneSpecularSample(vec3 dir, float power, inout float seed)
{
    return getConeSampleCosWeighted(dir, power, seed);
}



// NEE with MIS
float misWeight(float a, float b)
{
    return a*a / (a*a + b*b);
}
